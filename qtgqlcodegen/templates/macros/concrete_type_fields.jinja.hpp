{% macro concrete_type_fields(type) -%}
public:
{% for f in type.unique_fields -%}
{% set f_member_type -%}
{% if f.arguments -%}
std::map<ğŸ‘‰f.arguments_typeğŸ‘ˆ, ğŸ‘‰f.type.member_typeğŸ‘ˆ>
{% else -%}
ğŸ‘‰f.type.member_typeğŸ‘ˆ
{% endif -%}
{%- endset -%}
ğŸ‘‰ f_member_type ğŸ‘ˆ ğŸ‘‰ f.private_name ğŸ‘ˆ = ğŸ‘‰ f.default_value ğŸ‘ˆ;
{% endfor %}
signals:
{%for f in type.unique_fields -%}
void ğŸ‘‰ f.signal_name ğŸ‘ˆ();
{% endfor %}

public:
{%for f in type.unique_fields %}
[[nodiscard]] const ğŸ‘‰ f.type.fget_type ğŸ‘ˆ &ğŸ‘‰ f.getter_name ğŸ‘ˆ(
{%- if f.arguments -%}ğŸ‘‰ f.arguments_type ğŸ‘ˆ args {% endif -%}
) {%- if f.type.getter_is_constable -%}const{% endif %}{
{%- if f.arguments -%}
{% set f_private_name %}ğŸ‘‰ f.private_name ğŸ‘ˆ.at(args){% endset %}
{% else -%}
{% set f_private_name %}ğŸ‘‰ f.private_name ğŸ‘ˆ{% endset %}
{% endif -%}
{% if f.is_custom_scalar -%}
return ğŸ‘‰ f_private_name ğŸ‘ˆ.to_qt();
{% else -%}
return ğŸ‘‰ f_private_name ğŸ‘ˆ;
{% endif -%}
}
void ğŸ‘‰ f.setter_name ğŸ‘ˆ(ğŸ‘‰ f.type.member_type_arg ğŸ‘ˆ v{% if f.arguments %}, ğŸ‘‰ f.arguments_type ğŸ‘ˆ args {% endif %})
{
{%- if f.arguments -%}
{% set f_private_name %}ğŸ‘‰ f.private_name ğŸ‘ˆ[args]{% endset %}
{% else -%}
{% set f_private_name %}ğŸ‘‰ f.private_name ğŸ‘ˆ{% endset %}
{% endif -%}
ğŸ‘‰ f_private_name ğŸ‘ˆ = v;
emit ğŸ‘‰ f.signal_name ğŸ‘ˆ();
};
{% endfor %}
{% if type.implements_node -%}
public:
static std::optional<std::shared_ptr<ğŸ‘‰ type.name ğŸ‘ˆ>> get_node(const QString & id){
    auto node = ENV_CACHE()->get_node(id);
    if (node.has_value()){
        return std::static_pointer_cast<ğŸ‘‰ type.name ğŸ‘ˆ>(node.value());
    }
    return {};
}
{% endif %}
{% endmacro -%}

