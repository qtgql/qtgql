{%- from "macros/iterate_type_condition.jinja.hpp" import  iterate_type_condition -%}
{% macro update_proxy_field(field, operation) -%}
{% set new_concrete -%}
m_inst->ğŸ‘‰field.concrete.getter_nameğŸ‘ˆ(ğŸ‘‰field.build_variables_tuple_for_field_arguments ğŸ‘ˆ)
{%- endset -%}

{% if field.type.is_model -%}
    {% if field.type.of_type.is_queried_object_type and field.type.of_type.concrete.implements_node -%}
    {#- // the nodes themselves are updated as per normal (via deserializers) and here we only need
        // to set the nodes at the correct index and append them if they weren't existed so far.
    -#}
    auto operation = qobject_cast<ğŸ‘‰operation.nameğŸ‘ˆ*>(this->parent());
    auto new_data = ğŸ‘‰new_concreteğŸ‘ˆ;
    auto new_len = new_data.size();
    auto prev_len = ğŸ‘‰field.private_nameğŸ‘ˆ->rowCount();
    if (new_len < prev_len){
        ğŸ‘‰field.private_nameğŸ‘ˆ->removeRows(prev_len - 1, prev_len - new_len);
    }
    for (int i = 0; i < new_len; i++){
        auto concrete = new_data.at(i);
        if (i > prev_len - 1){
            ğŸ‘‰field.private_nameğŸ‘ˆ->insert(i, new ğŸ‘‰field.type.of_type.nameğŸ‘ˆ(operation, concrete));
        }
        else if (ğŸ‘‰field.private_nameğŸ‘ˆ->get(i)->get_id() != concrete->m_id){
            delete ğŸ‘‰field.private_nameğŸ‘ˆ->get(i);
            ğŸ‘‰field.private_nameğŸ‘ˆ->insert(i, new ğŸ‘‰field.type.of_type.nameğŸ‘ˆ(operation, concrete));
        }
    }
    {% else %}
    throw qtgql::excepctions::NotImplementedError({"can't update this model type ATM"});
    {% endif %}
{% elif field.type.is_queried_object_type -%}
auto operation = qobject_cast<ğŸ‘‰operation.nameğŸ‘ˆ*>(this->parent());
auto concrete = ğŸ‘‰new_concreteğŸ‘ˆ;
delete ğŸ‘‰field.private_nameğŸ‘ˆ;
ğŸ‘‰field.private_nameğŸ‘ˆ = new ğŸ‘‰field.type.nameğŸ‘ˆ(operation, concrete);
emit ğŸ‘‰ field.concrete.signal_name ğŸ‘ˆ();
{% elif field.type.is_queried_interface -%}
auto operation = qobject_cast<ğŸ‘‰operation.nameğŸ‘ˆ*>(this->parent());
auto concrete = ğŸ‘‰new_concreteğŸ‘ˆ;
delete ğŸ‘‰field.private_nameğŸ‘ˆ;
auto ğŸ‘‰field.nameğŸ‘ˆ_typename = concrete->__typename();
{%set type_cond -%}ğŸ‘‰field.nameğŸ‘ˆ_typename{% endset -%}
{% for choice in field.type.choices %}
{% set do_on_meets -%}
ğŸ‘‰field.private_nameğŸ‘ˆ = qobject_cast<const ğŸ‘‰field.type.nameğŸ‘ˆ *>(new ğŸ‘‰choice.nameğŸ‘ˆ(operation, std::static_pointer_cast<ğŸ‘‰choice.concrete.nameğŸ‘ˆ>(concrete)));
{% endset -%}
ğŸ‘‰iterate_type_condition(choice,type_cond, do_on_meets, loop)ğŸ‘ˆ
{% endfor %}
emit ğŸ‘‰ field.concrete.signal_name ğŸ‘ˆ();
{% else -%}
emit ğŸ‘‰ field.concrete.signal_name ğŸ‘ˆ();
{% endif -%}
{% endmacro %}