{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QtGQL","text":"<p> GraphQL client for Qt and QML. This library is an attempt to provide a high-level graphql client to the QT world.</p>"},{"location":"#similar-projects","title":"Similar projects","text":"<ul> <li>react-relay</li> <li>apollo-client</li> </ul>"},{"location":"#features-tbd","title":"Features - TBD","text":"<ul> <li>types:<ul> <li> Object Type</li> <li> Enum</li> <li> Custom scalar</li> <li> Union</li> <li> Interface</li> <li> Node Interface</li> <li>List of:<ul> <li> Object Type</li> <li> Scalar</li> <li> custom scalar</li> <li> Interface</li> <li> Union</li> <li> Enum</li> </ul> </li> </ul> </li> <li> Fragments</li> <li> Operation handlers (queries the server and deserialize data) for Query / Mutation / Subscription.</li> <li> Fully typed operation variables. (partially, see)</li> <li> Garbage collection. (partially, see)</li> </ul>"},{"location":"config/","title":"Configurations","text":""},{"location":"config/#config.QtGqlConfig","title":"<code>QtGqlConfig</code>","text":"<p>Encapsulates configurations for a qtgql-codegen application per GraphQL schema.</p> Source code in <code>qtgqlcodegen/config.py</code> <pre><code>@define(slots=False)\nclass QtGqlConfig:\n\"\"\"Encapsulates configurations for a qtgql-codegen application per GraphQL\n    schema.\"\"\"\ngraphql_dir: Path\n\"\"\"A directory contains.\n    - schema.graphql, represents the current schema definition at the server.\n    - operations.graphql, queries, mutations and subscription handlers would be generated based on the operations defined there.\n    \"\"\"\nenv_name: str = \"QGqlEnv\"\n\"\"\"The generated types would find the environment by this name.\n    Also the generated QML imports would fall under this namespace.\n    \"\"\"\ncustom_scalars: CustomScalarMap = Factory(dict)\n\"\"\"Mapping of custom scalars, respected by the schema evaluator.\"\"\"\nqml_plugins_path: str = \"${CMAKE_BINARY_DIR}/qml\"\n\"\"\"Qml plugins would be installed under this directory.\n    This should suffice for most basic setups.\n    \"\"\"\ngenerated_dir_name: str = \"__generated__\"\n\"\"\"The name of the directory that qtgql will create and dump the generated\n    sources.\"\"\"\n@cached_property\ndef schema_path(self) -&gt; Path:\nreturn self.graphql_dir / \"schema.graphql\"\n@cached_property\ndef operations_dir(self) -&gt; Path:\nreturn self.graphql_dir / \"operations.graphql\"\n@cached_property\ndef generated_dir(self) -&gt; Path:\nret = self.graphql_dir / self.generated_dir_name\nif not ret.exists():\nret.mkdir()\nreturn ret\n@cached_property\ndef _evaluator(self) -&gt; SchemaGenerator:\nreturn SchemaGenerator(\nconfig=self,\nschema=graphql.build_schema(\n(self.graphql_dir / \"schema.graphql\").resolve(True).read_text(\"utf-8\"),\n),\n)\n@property\ndef shared_lib_export_definition(self) -&gt; str:\nreturn f\"QTGQL_{self.env_name}_EXPORT\" f\"\"\ndef generate(self) -&gt; None:\nself._evaluator.dump()\ndef __attrs_post_init__(self):\nif self.custom_scalars != CUSTOM_SCALARS:\nself.custom_scalars.update(CUSTOM_SCALARS)\n</code></pre>"},{"location":"config/#config.QtGqlConfig.custom_scalars","title":"<code>custom_scalars: CustomScalarMap = Factory(dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Mapping of custom scalars, respected by the schema evaluator.</p>"},{"location":"config/#config.QtGqlConfig.env_name","title":"<code>env_name: str = 'QGqlEnv'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The generated types would find the environment by this name.</p> <p>Also the generated QML imports would fall under this namespace.</p>"},{"location":"config/#config.QtGqlConfig.generated_dir_name","title":"<code>generated_dir_name: str = '__generated__'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The name of the directory that qtgql will create and dump the generated sources.</p>"},{"location":"config/#config.QtGqlConfig.graphql_dir","title":"<code>graphql_dir: Path</code>  <code>instance-attribute</code>","text":"<p>A directory contains.</p> <ul> <li>schema.graphql, represents the current schema definition at the server.</li> <li>operations.graphql, queries, mutations and subscription handlers would be generated based on the operations defined there.</li> </ul>"},{"location":"config/#config.QtGqlConfig.qml_plugins_path","title":"<code>qml_plugins_path: str = '${CMAKE_BINARY_DIR}/qml'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Qml plugins would be installed under this directory.</p> <p>This should suffice for most basic setups.</p>"},{"location":"network-layers/","title":"Network layers","text":"<p>In order to know how to access your GraphQL server, QtGQL requires developers to provide an object implementing the <code>NetworkLayer</code> interface when creating an instance of a QtGQL Environment.</p> <p>The environment uses this network layer to execute queries, mutations, and (if your server supports them) subscriptions. This allows developers to use whatever transport (HTTP, WebSockets, etc.) and authentication is most appropriate for their application, decoupling the environment from the particulars of each application's network configuration.</p>"},{"location":"network-layers/#builtin-network-layers","title":"Builtin network layers","text":"<p>QtGQL provides some network layers that are widely spread out-of-the-box:</p>"},{"location":"network-layers/#graphql-over-http","title":"GraphQL-over-HTTP","text":"<p>HTTP is the most common choice as the client-server protocol when using GraphQL because of its ubiquity. However the GraphQL specification deliberately does not specify the transport layer. The closest thing to an official specification is the article Serving over HTTP. Leading implementations on both client and server have mostly upheld those best practices and thus established a de-facto standard that is commonly used throughout the ecosystem. This specification is intended to fill this gap by specifying how GraphQL should be served over HTTP. The main intention of this specification is to provide interoperability between different client libraries, tools and server implementations.</p> <p>To use this layer, you'll need to pass an instance of it to your environment.</p> <p>Example</p> <pre><code>auto env = std::shared_ptr&lt;qtgql::bases::Environment&gt;(\nnew qtgql::bases::Environment(\"Countries\",\nstd::unique_ptr&lt;qtgql::bases::NetworkLayerABC&gt;(\nnew qtgql::gqloverhttp::GraphQLOverHttp({\"https://countries.trevorblades.com/\"}))\n)\n);\nqtgql::bases::Environment::set_gql_env(env);\n</code></pre>"},{"location":"network-layers/#graphql-over-websocket","title":"GraphQL-over-WebSocket","text":"<p>A widely used protocol mainly for subscriptions.</p> <p>Example</p> <pre><code>auto env = std::shared_ptr&lt;qtgql::bases::Environment&gt;(\nnew qtgql::bases::Environment(\"FooBar\",\nstd::unique_ptr&lt;gqltransportws::GqlTransportWs&gt;(new gqltransportws::GqlTransportWs({.url={\"ws://foobar.com\"}}));\n)\n);\nqtgql::bases::Environment::set_gql_env(env);\n</code></pre>"},{"location":"network-layers/#create-your-own-network-layer","title":"Create your own network layer","text":"<p>To create your own network layer, you'll need to extend <code>qtgql::bases::NetworkLayerABC</code> You have to implement only one method namely <code>void execute(const std::shared_ptr&lt;HandlerABC&gt; &amp;handler)</code>.</p> <p>This method accepts a handler which will contain the query. Your network layer should communicate with the handler using - <code>on_next</code>: when a graphql message received (on queries and mutations there would only be one like this) - <code>on_error</code>: if there was any GraphQL error in the operation (network, errors should be handled separately). - <code>on_completed</code>: when the operation is completed.</p>"},{"location":"server-requirements/","title":"Server requirements","text":"<p>Note</p> <p>This document contains assumptions that QtGQL makes about your server. If your server does not comply with these you might experience unwanted behaviours or the codegen will just not work.</p>"},{"location":"server-requirements/#node-interface","title":"Node Interface","text":"<p>The Node interface is defined like this</p> <p><pre><code># An object with a Globally Unique ID\ninterface Node {\n# The ID of the object.\nid: ID!\n}\n</code></pre> Any object that implements this interface is considered globally unique, thus allowing certain optimizations to be implemented by the client (in this case QtGQL compiler).</p> <p>For example for this schema: <pre><code>interface Node {\nid: ID!\n}\ntype User implements Node {\nid: ID!\nname: String!\nage: Int!\nprofilePicture: String!\n}\ntype Query {\nme: User!\n}\ntype Mutation{\nchangeProfilePicture(source: String!): User!\n}\n</code></pre> If when you start the app you were querying for: <pre><code>me{\nname\nprofilePicture\n}\n</code></pre> And you got your image. All good for now. But then the user sent this mutation: <pre><code>changeProfilePicture(source: \"https://t.ly/q4akF\"){\nprofilePicture\n}\n</code></pre> You would need to imperatively update the picture link where ever you show that in the UI.</p> <p>But Node Interface saves you here, since there is only one instance of a node at an application lifetime, the picture will be updated automatically when this mutation arrives.</p> <p>This is not the only advantage, think of a case where some other fields might have changed in the server since you fetched them. If you were to fetch them in one operation the changes will be mirrored in all the other operations.</p>"},{"location":"server-requirements/#pure-fields","title":"Pure fields","text":"<p>All the fields in the server are considered Pure Functions. Meaning that they should return the same value if they were to be called with the same arguments.</p> <p>Warning</p> <p>This means i.e that if a field would be changed based on some arbitrary context (i.e headers) you might get unwanted behaviours.</p> <p>Not only that this assumption is a GraphQL best-practice, it also has a great benefit in global updates. To demonstrate the purpose of this specification image that operation X queried for <pre><code>me{\nname\nprofilePic\n}\n</code></pre></p> <p>And after a while operation Y queried for: <pre><code>me{\nnickName\nprofilePic\n}\n</code></pre> Assuming that the profile picture has changed, operation X would be updated as well with the new picture.</p>"},{"location":"dev/architecture/","title":"Architecture","text":""},{"location":"dev/architecture/#schema-and-operation-reasoningconcrete-and-proxy-schema","title":"Schema and operation reasoning\u2014(concrete and proxy Schema)","text":"<p>Each operation in QtGQL would generate a \"proxy schema\" that include only the used types in this operation and only the used fields in those types.</p>"},{"location":"dev/architecture/#cross-operation-updatesroot-types-are-singletons","title":"Cross-operation updates\u2014(Root types are \"singletons\")","text":"<p>If operation X fetched some data and operation Y is also relying on this data (or a fraction of it) it would be ideal that they would be able to update each other.</p> <p>To achieve this the <code>Mutation</code> /  <code>Subscription</code> / <code>Query</code> types are singletons-ish. They exist for as long as one operation is using them otherwise they are deleted and once an operation is instantiated a new instance would get created.</p>"},{"location":"dev/architecture/#memoized-fieldsbasic-caching","title":"Memoized fields\u2014(Basic caching)","text":"<ul> <li>Concrete fields are cached on the concrete instances.</li> <li>The concrete field type doesn't always (actually mostly doesn't) match its proxied type.</li> <li>Concrete fields that have arguments are cached by arguments to avoid unwanted updates check server-requirements for more details.</li> </ul>"},{"location":"dev/architecture/#garbage-collection","title":"Garbage collection","text":"<p>TBD</p>"},{"location":"dev/architecture/#node-interface","title":"Node Interface","text":"<p>TBD</p>"},{"location":"dev/architecture/#implementation-details","title":"Implementation details","text":"<p>The codegen would generate <code>&lt;OperationName&gt;.cpp/hpp</code> for each operation defined in <code>operaitons.graphql</code>.</p> <p>Every operation is entitled to:</p> <ul> <li>Deserialize and update (if needed) concrete types based on the specific fields was queried.</li> <li>Deserialize and update (if needed) proxy types based on the specific fields was queried.</li> <li>Connect to signals from the concrete instances to the proxied instances and update the proxied  and emit signals when needed.</li> </ul>"},{"location":"dev/contributing/","title":"Contributing","text":""},{"location":"dev/contributing/#fork","title":"Fork","text":"<p>To contribute create a fork and clone your fork locally.</p>"},{"location":"dev/contributing/#install-dependencies","title":"Install dependencies","text":"<p>We use Poetry for managing dependencies. <pre><code>poetry install\n</code></pre></p>"},{"location":"dev/contributing/#install-pre-commit-hooks","title":"Install pre-commit hooks","text":"<pre><code>pre-commit install\n</code></pre>"},{"location":"dev/contributing/#add-a-releasemd-file-that-describes-your-pr-in-the-project-root","title":"Add a <code>RELEASE.md</code> file that describes your PR  in the project root.","text":"<pre><code>Release type: &lt;patch/minor/major&gt;\n\n&lt;description&gt;\n</code></pre>"},{"location":"dev/contributing/#generate-tests-cases-files","title":"Generate tests cases files","text":"<p>Go to <code>tests/tests_codegen/testcases.py</code> call https://github.com/qtgql/qtgql/blob/a40852623739394dc3418df42831a17bb99997a5/tests/test_codegen/testcases.py#L1076 with the desired testcases.</p>"},{"location":"dev/contributing/#build","title":"Build","text":"<p>conan would generate cmake presets for IDE's usage as well. add the option <code>test_core</code> to build the tests for the core library. add the option <code>test_gen</code> to build the tests for the generated code.  ```bash poetry run conan build . -o test_core=True -o test_gen=True <pre><code>\n</code></pre></p>"},{"location":"dev/contributing/#testing","title":"Testing","text":"<p>Run tests GraphQL server <pre><code>poetry run python -m tests.scripts.tests_server\n</code></pre> Run pytest, CTest is called from python and C++ tests are collected automatically. <pre><code>poetry run pytest\n</code></pre></p>"},{"location":"dev/contributing/#documenting","title":"Documenting","text":"<p>Your changes require to update the docs? We use mkdocs-material</p> <p>run <code>poetry run mkdocs serve</code> for a local server.</p>"},{"location":"scalars/","title":"Scalars","text":"<p>The GraphQL specification includes default scalar types Int, Float, String, Boolean, and ID. Although these scalars cover the majority of use cases, some applications need to support other atomic data types (such as Date) or add validation to an existing type. To enable this, you can define custom scalar types.</p>"},{"location":"scalars/#builtins-scalars","title":"'Builtins' scalars","text":"<p>These scalars are represented by \"primitive\" type and not by our scalar proxy.</p> <ul> <li><code>String</code>, maps to <code>QString</code></li> <li><code>Int</code>, a signed 32-bit integer, maps to <code>int</code></li> <li><code>Float</code>, a signed double-precision floating-point value, maps to <code>f&lt;number&gt;</code></li> <li><code>Boolean</code>, true or false, maps to  <code>bool</code></li> <li><code>ID</code>, a specialised <code>String</code> for representing unique object identifiers, maps to <code>QString</code></li> <li><code>UUID</code>, maps to <code>QUuid</code></li> <li><code>Void</code>, <code>nullptr</code>.</li> </ul>"},{"location":"scalars/create_scalar/","title":"Create a Scalar","text":"<p>(outdated)</p>"},{"location":"scalars/create_scalar/#create-your-own-custom-scalar","title":"Create Your own custom scalar","text":"<p>Although QtGQL provides some frequently used scalars, you might have your own complex scalars.</p>"},{"location":"scalars/create_scalar/#tutorial-country-scalar","title":"Tutorial - Country scalar","text":"<p>In order to deserialize a scalar for it to be compatible with Qt we created <code>BaseCustomScalar</code>. For example if you have a scalar of country code, you want to show the user a readable value.</p> <p>Here is a simple implementation</p> <p><pre><code>from __future__ import annotations\nfrom qtgqlcodegen.py.runtime.custom_scalars import BaseCustomScalar\nfrom typing import Optional\ncountry_map = {\n'isr': 'israel'\n}\n# BaseCustomScalar[&lt;typeof default_value&gt;, &lt;typeof graphql_value&gt;]\nclass CountryCode(BaseCustomScalar[str, str]):\nGRAPHQL_NAME = \"CountryCode\"\nDEFAULT_VALUE = \"israel\"  # this would be the default value.\ndef parse_value(self) -&gt; str:\nreturn self._value  # used in operation variables.\n@classmethod\ndef deserialize(cls, v: Optional[str] = None) -&gt; CountryCode:\nif v:\nreturn cls(country_map[v])\nreturn cls()\ndef to_qt(self) -&gt; str:\nreturn self._value\nassert CountryCode.deserialize('isr').to_qt() == 'israel' == CountryCode().to_qt()\n</code></pre>     !!! Note         You would need to add this in your config     <pre><code># config.py\nfrom qtgqlcodegen.py.compiler.config import QtGqlConfig\nQtGqlConfig(custom_scalars={CountryCode.GRAPHQL_NAME: CountryCode}, ...)\n</code></pre></p>"},{"location":"scalars/create_scalar/#api","title":"API","text":""},{"location":"scalars/custom_scalars/","title":"Custom Scalars","text":"<p>(outdated)</p>"},{"location":"scalars/custom_scalars/#builtins-scalars","title":"'Builtins' scalars","text":"<p>QtGQL provides some custom scalars by default, they are intended to be compatible with Strawberry-GraphQL custom scalars, though you can override them.</p>"},{"location":"tutorials/countries/","title":"Countries","text":"<p>This Tutorial will walk you threw creating a Qt project using QtGQL from ground up.</p> <p>This subject of this project will be a QML application that shows countries information using a public GraphQL API that can be found here</p> <p>Final code at GitHub.</p>"},{"location":"tutorials/countries/#prerequisites","title":"Prerequisites","text":"<ul> <li>Required by QtGql:<ul> <li>Python &gt;= 3.8</li> <li>CMake</li> </ul> </li> <li>Required for this tutorial:<ul> <li>Conan C++ Package manager</li> <li>Python-Poetry installed we we'll use it to manage python dependencies for this tutorial though feel free to use any other python package manager.</li> </ul> </li> </ul>"},{"location":"tutorials/countries/#project-layout","title":"Project layout","text":"<p>Create a new directory named countries and setup your git/github.</p> <p>We will use the \"src\" + CMake layout.</p> <pre><code>countries\n\u251c\u2500\u2500 3rdparty\n\u251c\u2500\u2500 CMakeLists.txt\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 main.cpp\n    \u2514\u2500\u2500 qml\n        \u2514\u2500\u2500 main.qml\n</code></pre>"},{"location":"tutorials/countries/#setup-build-requirements-and-qtgql","title":"Setup Build requirements and QtGql","text":"<p>Add QtGQL as a submodule to 3rdparty directory. <pre><code>cd 3rdparty/ &amp;&amp; git submodule add https://github.com/qtgql/qtgql.git\ncd ..\n</code></pre> In order to build QtGQL you'll need Qt installed. for this tutorial we will use a conan recipe that will install Qt and set the needed variables for cmake, see the following note.</p> Install Qt <p>First  lets setup Python virtualenv using poetry.</p> <p><pre><code>poetry init\n</code></pre> just hit <code>Enter</code> until it is done.</p> <pre><code>poetry add conan aqtinstall\n</code></pre> <p>Note</p> <p>from now on every command should be prefixed with <code>poetry run &lt;command&gt;</code></p> <p>Now create this conan recipe. Note that this is not a usauall recipe because at the moment of creating this tutorial Qt6 wasn't working well with native conan. <code>./conanfile.py</code> <pre><code>from __future__ import annotations\nimport contextlib\nimport glob\nimport logging\nimport os\nimport subprocess\nfrom functools import cached_property\nfrom pathlib import Path\nfrom typing import ClassVar\nfrom venv import logger\nfrom conan import ConanFile\nfrom conan.tools.cmake import CMake, CMakeDeps, CMakeToolchain, cmake_layout\nclass PATHS:\nPROJECT_ROOT: ClassVar[Path] = Path(__file__).parent\nConanBool = [True, False]\n__version__: str = \"0.1.0\"\nclass QtGqlCountriesRecipe(ConanFile):\nsettings = \"os\", \"compiler\", \"build_type\", \"arch\"\nname = \"countries\"\nlicense = \"MIT\"\nversion = __version__\nbuild_policy = \"missing\"\nexports_sources = \"CMakeLists.txt\", \"src/*\"\ndef requirements(self) -&gt; None:\n...\ndef layout(self) -&gt; None:\ncmake_layout(self)\n@property\ndef os_name(self):\nreturn self.settings.os.value.lower()\ndef is_windows(self) -&gt; bool:\nreturn self.os_name == \"windows\"\ndef is_linux(self) -&gt; bool:\nreturn self.os_name == \"linux\"\n@cached_property\ndef qt_version(self) -&gt; str:\nreturn \"6.5.0\"\n@property\ndef qt_arch(self) -&gt; str:\nif self.is_linux():\nreturn \"gcc_64\"\nelif self.is_windows():\nreturn \"win64_mingw\"\n@cached_property\ndef aqt_install_dir(self) -&gt; Path:\nret = Path.home() / \"MyConnandeps\" / \"Qt\"\nif not ret.exists():\nret.mkdir(parents=True)\nreturn ret\n@property\ndef qt6_install_dir(self) -&gt; Path | None:\nrelative_to = self.aqt_install_dir / self.qt_version\nif relative_to.exists():\nprev = Path.cwd()\nos.chdir(relative_to)\nres = glob.glob(\"**/Qt6Config.cmake\", recursive=True)\nos.chdir(prev)\nwith contextlib.suppress(IndexError):\np = (relative_to / res[0]).resolve(True)\nreturn p.parent\ndef generate(self) -&gt; None:\nif not self.qt6_install_dir:\nsubprocess.run(\nf\"poetry run aqt install-qt {self.os_name} \"\nf\"desktop {self.qt_version} {self.qt_arch} \"\nf\"--outputdir {self.aqt_install_dir} \"\nf\"-m qtwebsockets\".split(\" \"),\n).check_returncode()\nos.environ.setdefault(\n\"QT_PLUGIN_PATH\",\n(self.qt6_install_dir.parent.parent.parent / \"plugins\").resolve(True).as_uri(),\n)\nos.environ.setdefault(\n\"LD_LIBRARY_PATH\",\n(self.qt6_install_dir.parent.parent.parent / \"lib\").resolve(True).as_uri(),\n)\npaths = os.environ.get(\"PATH\").split(\":\")\npaths.append((self.qt6_install_dir.parent.parent.parent / \"bin\").resolve(True).as_uri())\nos.environ.setdefault(\"PATH\", \":\".join(paths))\nassert self.qt6_install_dir\nassert self.qt6_install_dir.exists()\ndeps = CMakeDeps(self)\ndeps.generate()\ntc = CMakeToolchain(self)\ntc.cache_variables[\"Qt6_DIR\"] = str(self.qt6_install_dir)\ntc.generate()\ndef build(self):\ncmake = CMake(self)\ncmake.configure()\ncmake.build()\ndef package(self):\ncmake = CMake(self)\ncmake.install()\n</code></pre></p> <p>Now to install Qt run: <pre><code>poetry run conan install .\n</code></pre></p> <p>To install the <code>QtGQL</code> code-generator we need to add it as a Python dependency. We'll use Python-Poetry: <pre><code>poetry add \"3rdparty/qtgql/\"\n</code></pre></p> <p>Now lets setup CMake. Content of <code>./CMakeLists.txt</code> <pre><code>cmake_minimum_required(VERSION 3.25.0)\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\nproject(countries VERSION 0.1.0\nLANGUAGES CXX)\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nadd_subdirectory(3rdparty/qtgql)\nfind_package(Qt6 REQUIRED COMPONENTS Core Quick)\nadd_executable(${PROJECT_NAME}\n\"src/main.cpp\"\n)\ntarget_link_libraries(${PROJECT_NAME} PRIVATE qtgql::qtgql\nQt6::Core Qt6::Quick\n)\n</code></pre></p>"},{"location":"tutorials/countries/#set-up-a-qml-window","title":"Set up a QML window","text":"<p>Inside <code>main.cpp</code> past this code</p> <pre><code>#include &lt;QtGui&gt;\n#include &lt;QtQuick&gt;\n#include \"filesystem\"\nnamespace fs = std::filesystem;\nint main(int argc, char *argv[]){\nQGuiApplication app(argc, argv);\nQQmlApplicationEngine engine;\nQUrl url((fs::path(__FILE__).parent_path() / \"qml\" / \"main.qml\").c_str());\nengine.load(url);\nreturn QGuiApplication::exec();\n}\n</code></pre> <p>Inside <code>main.qml</code> past this code: <pre><code>import QtQuick\nWindow{\nwidth: 500;\nheight: 400;\nvisible: true;\nRectangle{\nanchors.fill: parent;\ncolor: \"red\";\n}\n}\n</code></pre></p> <p>Now lets build and run <pre><code>poetry run conan build .\nbuild/Debug/countries\n</code></pre> Now you should see something like this:</p> <p></p>"},{"location":"tutorials/countries/#using-the-countries-schema","title":"Using the countries' schema.","text":"<p>Create a directory for graphql, we'll call it <code>graphql</code></p> <p>Inside <code>graphql</code> create 3 files:</p> <ul> <li><code>schema.graphql</code>  This file describes your server schema.   (You can use the script below to fill it or copy it from here)</li> <li><code>operations.graphql</code> - Here you would define your operations.</li> <li><code>qtgqlconfig.py</code> - Here you would define configurations for <code>qtgql</code></li> </ul> script to fetch the schema <pre><code>from pathlib import Path\nfrom graphql import build_client_schema, get_introspection_query, print_schema\nimport requests\nres = requests.post(\"https://countries.trevorblades.com/\", json={\"query\": get_introspection_query()})\nres.raise_for_status()\nd = res.json()['data']\nclient_schema = build_client_schema(d)\nschema_file = Path(__file__).parent / \"schema.graphql\"\nschema_file.resolve(True).write_text(print_schema(client_schema))\n</code></pre> <p>by now you should have the following tree: <pre><code>countries\n\u251c\u2500\u2500 3rdparty\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 qtgql\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 &lt;etc&gt;\n\u251c\u2500\u2500 build\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 Debug\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 &lt;etc&gt;\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 CMakeUserPresets.json\n\u251c\u2500\u2500 conanfile.py\n\u251c\u2500\u2500 poetry.lock\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 graphql\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 operations.graphql\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 qtgqlconfig.py\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 schema.graphql\n    \u251c\u2500\u2500 main.cpp\n    \u2514\u2500\u2500 qml\n        \u2514\u2500\u2500 main.qml\n</code></pre></p> <p>Content of <code>qtgqlconfig.py</code> <pre><code>from pathlib import Path\nfrom qtgqlcodegen.config import QtGqlConfig\nconfig = QtGqlConfig(graphql_dir=Path(__file__).parent, env_name=\"Countries\")\n</code></pre> - <code>graphql_dir</code> - This would let QtGQL know where to find your schema and operation definition. - <code>env_name</code> - Will be used to namespace this schema at the generated code to avoid collisions with other potential schemas.</p>"},{"location":"tutorials/countries/#writing-your-first-query","title":"Writing your first query","text":"<p>QtGql is heavily relying on operations. Each operation would generate it's own types that mirror concrete types that would be generated inside <code>schema.hpp</code></p> <p>Inside <code>operations.graphql</code> create an operation that will query for all available countries:</p> <p><pre><code>query ContinentQuery($code: ID!){\ncontinent(code:$code){\nname\ncountries{\ncapital\nemoji\n}\n}\n}\n</code></pre> Now run the codegen from <code>src</code> dir: <pre><code>cd src &amp;&amp; poetry run qtgql gen\n</code></pre></p> <p>Now under <code>src/graphql</code> you should have the following: <pre><code>graphql\n\u251c\u2500\u2500 __generated__\n\u2502   \u251c\u2500\u2500 CMakeLists.txt\n\u2502   \u251c\u2500\u2500 ContinentQuery.cpp\n\u2502   \u251c\u2500\u2500 ContinentQuery.hpp\n\u2502   \u2514\u2500\u2500 schema.hpp\n\u251c\u2500\u2500 operations.graphql\n\u251c\u2500\u2500 qtgqlconfig.py\n\u2514\u2500\u2500 schema.graphql\n</code></pre></p>"},{"location":"tutorials/countries/#use-the-generated-code","title":"Use the generated code","text":"<p>First lets link our executable to the generated target. Update <code>CMakeLists.txt</code> <pre><code>cmake_minimum_required(VERSION 3.25.0)\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\nproject(countries VERSION 0.1.0\nLANGUAGES CXX)\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nadd_subdirectory(3rdparty/qtgql)\nfind_package(Qt6 REQUIRED COMPONENTS Core Quick)\nadd_executable(${PROJECT_NAME}\n\"src/main.cpp\"\n)\ntarget_link_libraries(${PROJECT_NAME} PRIVATE\nqtgql::qtgql\nQt6::Core Qt6::Quick\nCountries # Name of our environment\n)\n</code></pre> Now we'll set up the environment in C++ and fetch the first query. main.cpp <pre><code>#include &lt;QtGui&gt;\n#include &lt;QtQuick&gt;\n#include &lt;filesystem&gt;\n#include &lt;memory&gt;\n#include &lt;qtgql/bases/bases.hpp&gt;\n#include &lt;qtgql/gqloverhttp/gqloverhttp.hpp&gt;\n#include \"graphql/__generated__/ContinentQuery.hpp\"\nnamespace fs = std::filesystem;\nint main(int argc, char *argv[]){\nQGuiApplication app(argc, argv);\nQQmlApplicationEngine engine;\n// set up an environment\nauto env = std::shared_ptr&lt;qtgql::bases::Environment&gt;(\nnew qtgql::bases::Environment(\"Countries\",\nstd::shared_ptr&lt;qtgql::bases::NetworkLayerABC&gt;(new qtgql::gqloverhttp::GraphQLOverHttp({\"https://countries.trevorblades.com/\"})))\n);\n// Export it\nqtgql::bases::Environment::set_gql_env(env);\n// Create an operation handler\nauto cont_query = Countries::continentquery::ContinentQuery::shared();\ncont_query-&gt;set_variables(Countries::continentquery::ContinentQueryVariables{.code=\"EU\"});\ncont_query-&gt;execute();\nengine.rootContext()-&gt;setContextProperty(\"query\", cont_query.get());\nQUrl url((fs::path(__FILE__).parent_path() / \"qml\" / \"main.qml\").c_str());\nengine.load(url);\nreturn QGuiApplication::exec();\n}\n</code></pre> now update <code>main.qml</code> to show the data. <pre><code>import QtQuick\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nApplicationWindow {id:root\nwidth: 500;\nheight: 400;\nvisible: true;\nMaterial.theme: Material.Dark\nMaterial.accent: Material.Orange\nproperty var continent: query?.data?.continent;\nListView{id: countries_view\nanchors.fill: parent;\nmodel: root.continent?.countries;\nheader:Rectangle{\ncolor: Material.color(Material.Indigo)\nwidth: ListView.view.width;\nheight: 50;\nLabel{\nanchors.centerIn: parent;\ntext: `Countries in Continent ${root.continent?.name} (${countries_view.count}):`\n}\n}\ndelegate: Rectangle{\nid: country_delegate\nrequired property var model;\ncolor: (model.index % 2 == 0)? Material.color(Material.Grey):  Material.color(Material.BlueGrey)\nproperty var view: ListView.view;\nwidth: view.width;\nheight: 50;\nLabel{\nanchors.left: parent.left;\nproperty var country: country_delegate.model.data;\ntext: `${country_delegate.model.index + 1}:  ${country.emoji} capital: ${country.capital}`\n}\n}\n}\n}\n</code></pre> Should look like this: </p>"}]}